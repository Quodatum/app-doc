<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>XQuery documentation </title>
    <link rel="stylesheet" type="text/css" href="../../../style.css"></link>
  </head>
  <body>
    <div class="right">
      <img width="104" src="../../../basex.svg"></img>
    </div>
    <h2>Library Module: data/doc/basex.xqm/map.xqm</h2>
    <table>
      <tr>
        <td>
          <b>URI:</b>
        </td>
        <td>
          <code>x-http://www.w3.org/2005/xpath-functions/map</code>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>This <a href="http://docs.basex.org/wiki/Module_Library">XQuery Module</a> contains functions for manipulating maps, which will officially be introduced with <a href="http://docs.basex.org/wiki/XQuery_3.1#Maps">XQuery 3.1</a> . <br></br>  <b>Please note</b> that the functions are subject to change until the specification has reached its final stage.</td>
      </tr>
      <tr>
        <td>
          <b>Author:</b>
        </td>
        <td>BaseX Team</td>
      </tr>
      <tr>
        <td>
          <b>See:</b>
        </td>
        <td>http://docs.basex.org/wiki/Module_Library</td>
      </tr>
    </table>
    <h2>Functions</h2>
    <a name="contains#2">
      <h3>contains($input, $key)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$key</code>
              </td>
              <td>
                <code>xs:anyAtomicType</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:boolean</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns true if the <i>map</i> supplied as <code>$input</code> contains an entry with a key equal to the supplied value of <code>$key</code> ; otherwise it returns false. No error is raised if the map contains keys that are not comparable with the supplied <code>$key</code> . <p>If the supplied key is <code>xs:untypedAtomic</code>, it is compared as an instance of <code>xs:string</code>. If the supplied key is the <code>xs:float</code> or <code>xs:double</code> value <code>NaN</code>, the function returns true if there is an entry whose key is <code>NaN</code>, or false otherwise. </p>
        </td>
      </tr>
    </table>
    <a name="entry#2">
      <h3>entry($key, $value)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$key</code>
              </td>
              <td>
                <code>xs:anyAtomicType</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$value</code>
              </td>
              <td>
                <code>item()*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Creates a new <i>map</i> containing a single entry. The key of the entry in the new map is <code>$key</code> , and its associated value is <code>$value</code> . If the supplied key is <code>xs:untypedAtomic</code> , it is compared as an instance of <code>xs:string</code> . If the supplied key is the <code>xs:float</code> or <code>xs:double</code> value <code>NaN</code> , the function returns the value in the entry whose key is <code>NaN</code> , or the empty sequence otherwise. <p>The function <code>map:entry</code> is intended primarily for use in conjunction with the function <code> <a href="#map:merge">map:merge</a> </code>. For example, a map containing seven entries may be constructed like this: </p>  <pre class="brush:xquery"> map:merge(( map:entry("Su", "Sunday"), map:entry("Mo", "Monday"), map:entry("Tu", "Tuesday"), map:entry("We", "Wednesday"), map:entry("Th", "Thursday"), map:entry("Fr", "Friday"), map:entry("Sa", "Saturday") )) </pre>  <p>Unlike the <code>map { ... }</code> expression, this technique can be used to construct a map with a variable number of entries, for example: </p>  <pre class="brush:xquery">map:merge(for $b in //book return map:entry($b/isbn, $b))</pre>
        </td>
      </tr>
    </table>
    <a name="for-each#2">
      <h3>for-each($input, $fun)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$fun</code>
              </td>
              <td>
                <code>function(xs:anyAtomicType, item()*) as item()</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>item()*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Applies a function to every entry of the map <code>$input</code> and returns the results as a sequence. The function supplied as <code>$fun</code> takes two arguments. It is called supplying the key of the map entry as the first argument, and the associated value as the second argument.</td>
      </tr>
    </table>
    <a name="get#2">
      <h3>get($input, $key)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$key</code>
              </td>
              <td>
                <code>xs:anyAtomicType</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>item()*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the value associated with a supplied key in a given map. This function attempts to find an entry within the <i>map</i> supplied as <code>$input</code> that has a key equal to the supplied value of <code>$key</code> . If there is such an entry, it returns the associated value; otherwise it returns an empty sequence. No error is raised if the map contains keys that are not comparable with the supplied <code>$key</code> . If the supplied key is <code>xs:untypedAtomic</code> , it is converted to <code>xs:string</code> . If the supplied key is the <code>xs:float</code> or <code>xs:double</code> value <code>NaN</code> , the function returns an empty sequence. <p>A return value of <code>()</code> from <code>map:get</code> could indicate that the key is present in the map with an associated value of <code>()</code>, or it could indicate that the key is not present in the map. The two cases can be distinguished by calling <code>map:contains</code>. Invoking the <i>map</i> as a function item has the same effect as calling <code>get</code>: that is, when <code>$input</code> is a map, the expression <code>$input($K)</code> is equivalent to <code>get($input, $K)</code>. Similarly, the expression <code>get(get(get($input, 'employee'), 'name'), 'first')</code> can be written as <code>$input('employee')('name')('first')</code>. </p>
        </td>
      </tr>
    </table>
    <a name="keys#1">
      <h3>keys($input)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:anyAtomicType*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a sequence containing all the key values present in a map. The function takes any <i>map</i> as its <code>$input</code> argument and returns the keys that are present in the map as a sequence of atomic values. The order may differ from the order in which entries were inserted in the map.</td>
      </tr>
    </table>
    <a name="merge#1">
      <h3>merge($input)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Constructs and returns a new map. The <i>map</i> is formed by combining the contents of the maps supplied in the <code>$input</code> argument. The maps are combined as follows: <ol> <li> There is one entry in the new map for each distinct key value present in the union of the input maps, where keys are considered distinct according to the rules of the <code>distinct-values</code> function. </li> <li> The associated value for each such key is taken from the last map in the input sequence <code>$input</code> that contains an entry with this key. </li> </ol>  <p>There is no requirement that the supplied input maps should have the same or compatible types. The type of a map (for example <code>map(xs:integer, xs:string)</code>) is descriptive of the entries it currently contains, but is not a constraint on how the map may be combined with other maps. </p>
        </td>
      </tr>
    </table>
    <a name="put#3">
      <h3>put($input, $key, $value)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$key</code>
              </td>
              <td>
                <code>xs:anyAtomicType</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$value</code>
              </td>
              <td>
                <code>item()*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Creates a new <i>map</i> , containing the entries of the <code>$input</code> argument and a new entry composed by <code>$key</code> and <code>$value</code> . The semantics of this function are equivalent to <code>map:merge(($input, map { $key, $value }))</code>
        </td>
      </tr>
    </table>
    <a name="remove#2">
      <h3>remove($input, $key)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$key</code>
              </td>
              <td>
                <code>xs:anyAtomicType</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Constructs a new map by removing an entry from an existing map. The entries in the new map correspond to the entries of <code>$input</code> , excluding any entry whose key is equal to <code>$key</code> . <p>No failure occurs if the input map contains no entry with the supplied key; the input map is returned unchanged </p>
        </td>
      </tr>
    </table>
    <a name="serialize#1">
      <h3>serialize($input)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>This function is specific to BaseX. It returns a string representation of the supplied map. The purpose of this function is to get an insight into the structure of a map item; it cannot necessarily be used for reconstructing the original map.</td>
      </tr>
    </table>
    <a name="size#1">
      <h3>size($input)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$input</code>
              </td>
              <td>
                <code>map(*)</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a the number of entries in the supplied map. The function takes any <i>map</i> as its <code>$input</code> argument and returns the number of entries that are present in the map.</td>
      </tr>
    </table>
  </body>
</html>