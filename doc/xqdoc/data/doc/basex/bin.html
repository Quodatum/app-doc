<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>XQuery documentation </title>
    <link rel="stylesheet" type="text/css" href="../../../style.css"></link>
  </head>
  <body>
    <div class="right">
      <img width="104" src="../../../basex.svg"></img>
    </div>
    <h2>Library Module: data/doc/basex.xqm/bin.xqm</h2>
    <table>
      <tr>
        <td>
          <b>URI:</b>
        </td>
        <td>
          <code>http://expath.org/ns/binary</code>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>This <a href="http://docs.basex.org/wiki/Module_Library">XQuery Module</a> contains functions to process binary data, including extracting subparts, searching, basic binary operations and conversion between binary and structured forms. This module is based on the <a href="http://expath.org/spec/binary">EXPath Binary Module</a> .</td>
      </tr>
      <tr>
        <td>
          <b>Author:</b>
        </td>
        <td>BaseX Team</td>
      </tr>
      <tr>
        <td>
          <b>See:</b>
        </td>
        <td>http://docs.basex.org/wiki/Module_Library</td>
      </tr>
    </table>
    <h2>Functions</h2>
    <a name="and#2">
      <h3>and($a, $b)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$a</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$b</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the "bitwise and" of two binary arguments.
If either argument is the empty sequence, an empty sequence is returned.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:differing-length-arguments the input arguments are of differing length.</td>
      </tr>
    </table>
    <a name="bin#1">
      <h3>bin($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the binary form of the set of octets written as a sequence of (8-wise) (ASCII) binary digits ([01]).
<code>$in</code> will be effectively zero-padded from the left to generate an integral number of octets. If <code>$in</code> is an empty string, then the result will be an <code>xs:base64Binary</code> with no embedded data. Byte order in the result follows (per-octet) character order in the string. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:non-numeric-character the input cannot be parsed as a binary number.</td>
      </tr>
    </table>
    <a name="decode-string#2">
      <h3>decode-string($in, $encoding)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$encoding</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Decodes binary data as a string in a given <code>$encoding</code> .
If <code>$offset</code> and <code>$size</code> are provided, the <code>$size</code> octets from <code>$offset</code> are decoded. If <code>$offset</code> alone is provided, octets from <code>$offset</code> to the end are decoded.If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-encoding the specified encoding is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:conversion-error an error or malformed input occurred during decoding the string.</td>
      </tr>
    </table>
    <a name="decode-string#3">
      <h3>decode-string($in, $encoding, $offset)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$encoding</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Decodes binary data as a string in a given <code>$encoding</code> .
If <code>$offset</code> and <code>$size</code> are provided, the <code>$size</code> octets from <code>$offset</code> are decoded. If <code>$offset</code> alone is provided, octets from <code>$offset</code> to the end are decoded.If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-encoding the specified encoding is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:conversion-error an error or malformed input occurred during decoding the string.</td>
      </tr>
    </table>
    <a name="decode-string#4">
      <h3>decode-string($in, $encoding, $offset, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$encoding</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Decodes binary data as a string in a given <code>$encoding</code> .
If <code>$offset</code> and <code>$size</code> are provided, the <code>$size</code> octets from <code>$offset</code> are decoded. If <code>$offset</code> alone is provided, octets from <code>$offset</code> to the end are decoded.If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-encoding the specified encoding is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:conversion-error an error or malformed input occurred during decoding the string.</td>
      </tr>
    </table>
    <a name="encode-string#2">
      <h3>encode-string($in, $encoding)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$encoding</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Encodes a string into binary data using a given <code>$encoding</code> .
If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-encoding the specified encoding is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:conversion-error an error or malformed input occurred during encoding the string.</td>
      </tr>
    </table>
    <a name="find#3">
      <h3>find($in, $offset, $search)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$search</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the first location of the binary search sequence in the input, or if not found, the empty sequence.
The <code>$offset</code> and the returned location are zero based. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
    </table>
    <a name="from-octets#1">
      <h3>from-octets($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:integer*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Converts a sequence of octets into binary data.
Octets are integers from 0 to 255. If the value of <code>$in</code> is the empty sequence, the function returns zero-sized binary data.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:octet-out-of-range one of the octets lies outside the range 0 - 255.</td>
      </tr>
    </table>
    <a name="hex#1">
      <h3>hex($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the binary form of the set of octets written as a sequence of (ASCII) hex digits ([0-9A-Fa-f]).
<code>$in</code> will be effectively zero-padded from the left to generate an integral number of octets, i.e. an even number of hexadecimal digits. If <code>$in</code> is an empty string, then the result will be an <code>xs:base64Binary</code> with no embedded data. Byte order in the result follows (per-octet) character order in the string. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:non-numeric-character the input cannot be parsed as a hexadecimal number.</td>
      </tr>
    </table>
    <a name="insert-before#3">
      <h3>insert-before($in, $offset, $extra)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$extra</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns binary data consisting sequentially of the data from <code>$in</code> up to and including the <code>$offset - 1</code> octet, followed by all the data from <code>$extra</code> , and then the remaining data from <code>$in</code> .
The <code>$offset</code> is zero based. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset is out of range.</td>
      </tr>
    </table>
    <a name="join#1">
      <h3>join($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an <code>xs:base64Binary</code> created by concatenating the items in the sequence <code>$in</code> , in order. If the value of <code>$in</code> is the empty sequence, the function returns a binary item containing no data bytes.</td>
      </tr>
    </table>
    <a name="length#1">
      <h3>length($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the size of binary data in octets.</td>
      </tr>
    </table>
    <a name="not#1">
      <h3>not($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the "bitwise not" of a binary argument.
If the argument is the empty sequence, an empty sequence is returned.</td>
      </tr>
    </table>
    <a name="octal#1">
      <h3>octal($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:string?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the binary form of the set of octets written as a sequence of (ASCII) octal digits ([0-7]).
<code>$in</code> will be effectively zero-padded from the left to generate an integral number of octets. If <code>$in</code> is an empty string, then the result will be an <code>xs:base64Binary</code> with no embedded data. Byte order in the result follows (per-octet) character order in the string. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:non-numeric-character the input cannot be parsed as an octal number.</td>
      </tr>
    </table>
    <a name="or#2">
      <h3>or($a, $b)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$a</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$b</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the "bitwise or" of two binary arguments.
If either argument is the empty sequence, an empty sequence is returned.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:differing-length-arguments the input arguments are of differing length.</td>
      </tr>
    </table>
    <a name="pack-double#1">
      <h3>pack-double($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:double</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the 8-octet binary representation of a double value.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="pack-double#2">
      <h3>pack-double($in, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:double</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the 8-octet binary representation of a double value.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="pack-float#1">
      <h3>pack-float($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:float</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the 4-octet binary representation of a float value.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="pack-float#2">
      <h3>pack-float($in, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:float</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the 4-octet binary representation of a float value.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="pack-integer#2">
      <h3>pack-integer($in, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the twos-complement binary representation of an integer value treated as <code>$size</code> octets long. Any 'excess' high-order bits are discarded.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. Specifying a <code>$size</code> of zero yields an empty binary data.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
    </table>
    <a name="pack-integer#3">
      <h3>pack-integer($in, $size, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the twos-complement binary representation of an integer value treated as <code>$size</code> octets long. Any 'excess' high-order bits are discarded.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. Specifying a <code>$size</code> of zero yields an empty binary data.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
    </table>
    <a name="pad-left#2">
      <h3>pad-left($in, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an <code>xs:base64Binary</code> created by padding the input with <code>$size</code> octets in front of the input. If <code>$octet</code> is specified, the padding octets each have that value, otherwise they are zero.
If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:octet-out-of-range the specified octet lies outside the range 0-255.</td>
      </tr>
    </table>
    <a name="pad-left#3">
      <h3>pad-left($in, $size, $octet)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an <code>xs:base64Binary</code> created by padding the input with <code>$size</code> octets in front of the input. If <code>$octet</code> is specified, the padding octets each have that value, otherwise they are zero.
If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:octet-out-of-range the specified octet lies outside the range 0-255.</td>
      </tr>
    </table>
    <a name="pad-right#2">
      <h3>pad-right($in, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an <code>xs:base64Binary</code> created by padding the input with <code>$size</code> octets after the input. If <code>$octet</code> is specified, the padding octets each have that value, otherwise they are zero.
If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:octet-out-of-range the specified octet lies outside the range 0-255.</td>
      </tr>
    </table>
    <a name="pad-right#3">
      <h3>pad-right($in, $size, $octet)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an <code>xs:base64Binary</code> created by padding the input with <code>$size</code> octets after the input. If <code>$octet</code> is specified, the padding octets each have that value, otherwise they are zero.
If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:octet-out-of-range the specified octet lies outside the range 0-255.</td>
      </tr>
    </table>
    <a name="part#2">
      <h3>part($in, $offset)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a section of binary data starting at the <code>$offset</code> octet.
If <code>$size</code> is specified, the size of the returned binary data is <code>$size</code> octets. If <code>$size</code> is absent, all remaining data from <code>$offset</code> is returned. The <code>$offset</code> is zero based. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
    </table>
    <a name="part#3">
      <h3>part($in, $offset, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a section of binary data starting at the <code>$offset</code> octet.
If <code>$size</code> is specified, the size of the returned binary data is <code>$size</code> octets. If <code>$size</code> is absent, all remaining data from <code>$offset</code> is returned. The <code>$offset</code> is zero based. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
    </table>
    <a name="shift#2">
      <h3>shift($in, $by)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$by</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Shifts bits in binary data.
If <code>$by</code> is zero, the result is identical to <code>$in</code> . If <code>$by</code> is positive then bits are shifted to the left. Otherwise, bits are shifted to the right. If the absolute value of <code>$by</code> is greater than the bit-length of <code>$in</code> then an all-zeros result is returned. The result always has the same size as <code>$in</code> . The shifting is logical: zeros are placed into discarded bits. If the value of <code>$in</code> is the empty sequence, the function returns an empty sequence.</td>
      </tr>
    </table>
    <a name="to-octets#1">
      <h3>to-octets($in)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer*</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns binary data as a sequence of octets.
If <code>$in</code> is a zero length binary data then the empty sequence is returned. Octets are returned as integers from 0 to 255.</td>
      </tr>
    </table>
    <a name="unpack-double#2">
      <h3>unpack-double($in, $offset)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:double</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Extracts the double value stored at the particular offset in binary data.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-double#3">
      <h3>unpack-double($in, $offset, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:double</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Extracts the double value stored at the particular offset in binary data.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-float#2">
      <h3>unpack-float($in, $offset)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:float</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Extracts the float value stored at the particular offset in binary data.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-float#3">
      <h3>unpack-float($in, $offset, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:float</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Extracts the float value stored at the particular offset in binary data.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-integer#3">
      <h3>unpack-integer($in, $offset, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a signed integer value represented by the <code>$size</code> octets starting from <code>$offset</code> in the input binary representation. Necessary sign extension is performed (i.e. the result is negative if the high order bit is '1').
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based. Specifying a <code>$size</code> of zero yields the integer <code>0</code> .</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-integer#4">
      <h3>unpack-integer($in, $offset, $size, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns a signed integer value represented by the <code>$size</code> octets starting from <code>$offset</code> in the input binary representation. Necessary sign extension is performed (i.e. the result is negative if the high order bit is '1').
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based. Specifying a <code>$size</code> of zero yields the integer <code>0</code> .</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-unsigned-integer#3">
      <h3>unpack-unsigned-integer($in, $offset, $size)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an unsigned integer value represented by the <code>$size</code> octets starting from <code>$offset</code> in the input binary representation.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based. Specifying a <code>$size</code> of zero yields the integer <code>0</code> .</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="unpack-unsigned-integer#4">
      <h3>unpack-unsigned-integer($in, $offset, $size, $octet-order)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$in</code>
              </td>
              <td>
                <code>xs:base64Binary</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$offset</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$size</code>
              </td>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$octet-order</code>
              </td>
              <td>
                <code>xs:string</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:integer</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns an unsigned integer value represented by the <code>$size</code> octets starting from <code>$offset</code> in the input binary representation.
Most-significant-octet-first number representation is assumed unless the <code>$octet-order</code> parameter is specified. The <code>$offset</code> is zero based. Specifying a <code>$size</code> of zero yields the integer <code>0</code> .</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:negative-size the specified size is negative.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:index-out-of-range the specified offset + size is out of range.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:unknown-significance-order the specified octet order is unknown.</td>
      </tr>
    </table>
    <a name="xor#2">
      <h3>xor($a, $b)</h3>
    </a>
    <table>
      <tr>
        <td>
          <b>Arguments:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>$a</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <code>$b</code>
              </td>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Returns:</b>
        </td>
        <td>
          <table>
            <tr>
              <td>
                <code>xs:base64Binary?</code>
              </td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Description:</b>
        </td>
        <td>Returns the "bitwise xor" of two binary arguments.
If either argument is the empty sequence, an empty sequence is returned.</td>
      </tr>
      <tr>
        <td>
          <b>Error:</b>
        </td>
        <td>:differing-length-arguments the input arguments are of differing length.</td>
      </tr>
    </table>
  </body>
</html>